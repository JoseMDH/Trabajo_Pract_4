% Diseño

En esta sección se describen las principales decisiones de diseño tanto a nivel lógico como de interacción con el sistema.

\section*{Patrones y decisiones}

A nivel lógico se ha optado por una arquitectura por capas:

\begin{itemize}
  \item \textbf{Capa de sensores}: formada por un esclavo (Arduino UNO) y un maestro (MKR WAN 1310). El esclavo encapsula el acceso hardware a los sensores (I\textsuperscript{2}C para SRF01/SRF02 y analógico para la LDR) detrás de un protocolo serie simple. El maestro actúa como único punto que interpreta las medidas, aplica umbrales y decide estados lógicos.
  \item \textbf{Capa de transporte LoRa}: el maestro y el gateway intercambian tramas LoRa con cabeceras explícitas (direcciones, identificador de mensaje, longitud), lo que permite dirigir mensajes a distintos nodos (gateway, actuador) y asociar ACKs a comandos concretos.
  \item \textbf{Capa de integración MQTT}: en la Raspberry Pi, un proceso puente traduce entre el protocolo serie del gateway y mensajes MQTT, mapeando topics internos (\texttt{sensor/0}, \texttt{sensor/1}) a topics lógicos (\texttt{sensores/puerta}, \texttt{sensores/luz}). Esta capa aplica además políticas de \emph{rate limiting} y eliminación de duplicados para no saturar LoRa.
  \item \textbf{Capa de presentación}: formada por el dashboard web y herramientas como \texttt{mosquitto\_sub}/\texttt{mosquitto\_pub}. Estas aplicaciones solo ven topics MQTT y no necesitan conocer detalles de LoRa ni del protocolo maestro--esclavo.
\end{itemize}

Esta separación responde a dos decisiones clave:

\begin{itemize}
  \item Mantener los nodos embebidos (maestro, esclavo, actuador) lo más simples posible, delegando el tratamiento de mensajes, la conversión de formatos y la integración con otras aplicaciones en la Raspberry Pi.
  \item Utilizar formatos binarios compactos en los enlaces de menor ancho de banda (LoRa y UART) y formatos más ricos (cadenas y JSON) en MQTT, donde el coste en bytes es menos crítico.
\end{itemize}

En cuanto al control, el maestro solo envía nuevas órdenes cuando detecta un cambio de estado (por ejemplo, de luz=0 a luz=1), y el actuador siempre responde con un ACK con el mismo identificador de mensaje. El gateway reintenta automáticamente las transmisiones si no recibe ese ACK dentro de un tiempo máximo.

\section*{Prototipos/Mockups}

Aunque el proyecto no es una aplicación móvil, se ha diseñado una interfaz web sencilla como dashboard de usuario final. La página muestra dos tarjetas principales:

\begin{itemize}
  \item \textbf{Sensor de luz}: icono y estado textual (\emph{oscuro} / \emph{iluminado}), con dos botones para enviar manualmente valores 0 o 1 sobre el topic \texttt{sensores/luz}.
  \item \textbf{Sensor de puerta}: icono de puerta y estado (\emph{cerrada/nadie} o \emph{abierta/gente}), de nuevo con botones para forzar los estados 0 o 1 sobre \texttt{sensores/puerta}.
\end{itemize}

Además, el dashboard incluye indicadores de conexión (estado de la conexión web y del broker MQTT) y un panel de log donde se registran los eventos relevantes (nuevos valores recibidos, comandos enviados, pérdidas de conexión).

A nivel de diseño de interacción se ha priorizado:

\begin{itemize}
  \item Representar los estados con emojis e indicadores de color para facilitar una lectura rápida.
  \item Mostrar claramente si el sistema está conectado al broker MQTT y si la web está sincronizada con el estado actual.
  \item Registrar un histórico de eventos para ayudar en la depuración durante las pruebas.
\end{itemize}

% Si quieres, puedes sustituir la figura de ejemplo por una captura real del dashboard.
\begin{figure}[H]
  \centering
  \fbox{\rule{0pt}{120pt}\rule{180pt}{0pt}}
  \caption{Borrador del dashboard web con estados de luz y puerta.}
  \label{fig:mapa-navegacion}
\end{figure}
