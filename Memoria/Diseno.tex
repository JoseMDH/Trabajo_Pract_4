% Diseño

En esta sección se describen las principales decisiones de diseño tanto a nivel lógico como de interacción con el sistema.

\section*{Patrones y decisiones}

A nivel lógico se ha optado por una arquitectura por capas:

\begin{itemize}
  \item \textbf{Capa de sensores}: formada por un esclavo y un maestro (MKR WAN 1310). El esclavo encapsula el 
  acceso hardware a los sensores (I\textsuperscript{2}C para SRF01/SRF02 y analógico para la LDR) detrás de un protocolo serie 
  simple. El maestro actúa como único punto que interpreta las medidas, aplica umbrales y decide estados lógicos.
  \item \textbf{Capa de transporte LoRa}: el maestro y el gateway intercambian tramas LoRa con cabeceras explícitas 
  (direcciones, identificador de mensaje, longitud), lo que permite dirigir mensajes a distintos nodos (gateway, actuador) y 
  asociar ACKs a comandos concretos.
  \item \textbf{Capa de integración MQTT}: en la Raspberry Pi, un proceso puente traduce entre el protocolo serie del gateway y
   mensajes MQTT, mapeando topics internos (\texttt{sensor/0}, \texttt{sensor/1}) a topics lógicos (\texttt{sensores/puerta}, 
   \texttt{sensores/luz}). Esta capa aplica además políticas de \emph{rate limiting} y eliminación de duplicados para no saturar LoRa.
  \item \textbf{Capa de presentación}: formada por el dashboard web y 
  herramientas como \texttt{mosquitto\_sub}/\texttt{mosquitto\_pub}. Estas aplicaciones solo ven topics MQTT y no necesitan conocer 
  detalles de LoRa ni del protocolo maestro--esclavo.
\end{itemize}

Esta separación responde a dos decisiones clave:

\begin{itemize}
  \item Mantener los nodos embebidos (maestro, esclavo, actuador) lo más simples posible, delegando el tratamiento de mensajes, 
  la conversión de formatos y la integración con otras aplicaciones en la Raspberry Pi.
  \item Utilizar formatos binarios compactos en los enlaces de menor ancho de banda (LoRa y UART) y formatos más ricos 
  (cadenas y JSON) en MQTT, donde el coste en bytes es menos crítico.
\end{itemize}

En cuanto al control, el maestro solo envía nuevas órdenes cuando detecta un cambio de estado (por ejemplo, de luz=0 a luz=1), 
y el actuador siempre responde con un ACK con el mismo identificador de mensaje. El gateway reintenta automáticamente las 
transmisiones si no recibe ese ACK dentro de un tiempo máximo.

\section*{Prototipos/Mockups}

Aunque el proyecto no es una aplicación móvil, se ha diseñado una interfaz web sencilla como dashboard de usuario final. 
La página muestra dos tarjetas principales:

\begin{itemize}
  \item \textbf{Sensor de luz}: icono y estado textual (\emph{oscuro} / \emph{iluminado}), con dos botones para enviar manualmente 
  valores 0 o 1 sobre el topic \texttt{sensores/luz}.
  \item \textbf{Sensor de puerta}: icono de puerta y estado (\emph{cerrada/nadie} o \emph{abierta/gente}), de nuevo con botones 
  para forzar los estados 0 o 1 sobre \texttt{sensores/puerta}.
\end{itemize}

Además, el dashboard incluye indicadores de conexión (estado de la conexión web y del broker MQTT) y un panel de log donde 
se registran los eventos relevantes (nuevos valores recibidos, comandos enviados, pérdidas de conexión).

A nivel de diseño de interacción se ha priorizado:

\begin{itemize}
  \item Representar los estados con emojis e indicadores de color para facilitar una lectura rápida.
  \item Mostrar claramente si el sistema está conectado al broker MQTT y si la web está sincronizada con el estado actual.
  \item Registrar un histórico de eventos para ayudar en la depuración durante las pruebas.
\end{itemize}


\begin{figure}[H]
  \centering
  \begin{subfigure}[b]{0.48\textwidth}
    \centering
    \includegraphics[width=\linewidth]{./CapturasDashboard/1.png}
    \caption{Dashboard — Escritorio (1)}
    \label{fig:dash-escritorio-1}
  \end{subfigure}%
  \hfill
  \begin{subfigure}[b]{0.48\textwidth}
    \centering
    \includegraphics[width=\linewidth]{./CapturasDashboard/2.png}
    \caption{Dashboard — Escritorio (2)}
    \label{fig:dash-escritorio-2}
  \end{subfigure}
  \vspace{4mm}
  \begin{subfigure}[b]{0.48\textwidth}
    \centering
    \includegraphics[width=0.48\linewidth]{./CapturasDashboard/3.png}
    \caption{Dashboard — Móvil (3)}
    \label{fig:dash-movil-3}
  \end{subfigure}%
  \hfill
  \begin{subfigure}[b]{0.48\textwidth}
    \centering
    \includegraphics[width=0.48\linewidth]{./CapturasDashboard/4.png}
    \caption{Dashboard — Móvil (4)}
    \label{fig:dash-movil-4}
  \end{subfigure}
  \caption{Capturas del dashboard en escritorio (1–2) y móvil (3–4).}
  \label{fig:capturas-dashboard}
\end{figure}

\subsection*{Diseño de la arquitectura del sistema}
La arquitectura del sistema se basa en una comunicación jerárquica y modular entre los distintos componentes, cada uno con 
responsabilidades claras:
\begin{itemize}
  \item \textbf{Esclavo de sensores}: encargado de la adquisición de datos desde los sensores físicos (LDR y SRF01/SRF02) y de 
  enviarlos al maestro a través del canal serie.
  \item \textbf{Maestro de sensores}: recibe los datos del esclavo, procesa las mediciones aplicando umbrales para determinar 
  estados lógicos, y gestiona la comunicación inalámbrica mediante LoRa con el gateway.
  \item \textbf{Gateway LoRa}: actúa como intermediario entre el maestro y la Raspberry Pi, recibiendo los mensajes LoRa y 
  retransmitiéndolos a través del puerto serie y recibiendo los mensajes MQTT desde la raspberry y retransmitiéndolos por LoRa.
  \item \textbf{Raspberry Pi}: ejecuta un proceso puente que traduce los mensajes del gateway a formato MQTT, aplicando 
  políticas de filtrado y mapeo de topics. Además, aloja el broker MQTT y el dashboard web.
  \item \textbf{Dashboard web}: proporciona una interfaz de usuario para visualizar el estado de los sensores y enviar comandos
   manuales a través de MQTT.
\end{itemize}
\subsubsection*{Diagrama de arquitectura del sistema}
\begin{figure}[H]
  \centering
  \shorthandoff{<>}%
  \resizebox{\textwidth}{!}{%
    \begin{tikzpicture}[
      box/.style={draw, rounded corners, minimum width=30mm, minimum height=10mm, align=center, fill=white, font=\scriptsize},
      serial/.style={-{Stealth}, thick},
      lora/.style={-{Stealth}, thick, dashed},
      lbl/.style={font=\tiny, align=center}
    ]

    % Nodes
    \node[box] (esclavo) {ESCLAVO\\(Arduino UNO)\\Luz/SRF};
    \node[box,right=30mm of esclavo] (maestro) {MAESTRO\\(MKR WAN)\\LoRa TX};
    \node[box,below=15mm of maestro] (gateway) {GATEWAY\\(MKR WAN)\\LoRa RX/TX};
    \node[box,left=30mm of gateway] (raspi) {RASPBERRY PI\\MQTT Broker};
    \node[box,right=30mm of gateway] (actuador) {ACTUADOR\\(Arduino UNO)\\LED/Servo};
    \node[box,below=15mm of raspi] (apps) {APLICACIONES\\Dashboard};

    % Connections
    \draw[serial] (esclavo) -- node[midway,above,lbl]{Serial} (maestro);
    \draw[lora] (maestro.south) .. controls +(0,-8mm) and +(0,8mm) .. node[midway,right=1mm,lbl]{LoRa} (gateway.north);
    \draw[<->, thick] (gateway.west) -- node[midway,above,lbl]{Serial (GPIO UART)} (raspi.east);
    \draw[lora] (gateway.east) -- node[midway,above,lbl]{LoRa} (actuador.west);
    \draw[serial] (raspi) -- node[midway,left,lbl]{MQTT} (apps);

    \end{tikzpicture}%
  }%
  \shorthandon{<>}%

  % Leyenda separada, debajo del dibujo
  \vspace{2mm}
  \begin{tikzpicture}[
    serial/.style={-{Stealth}, thick},
    lora/.style={-{Stealth}, thick, dashed}
  ]
    \node[anchor=west,font=\small] at (0,0) {\textbf{Leyenda:}};
    \draw[serial] (0,-0.5) -- ++(1,0) node[right=2mm,font=\tiny] {Serial / MQTT};
    \draw[lora] (4,-0.5) -- ++(1,0) node[right=2mm,font=\tiny] {LoRa (dashed)};
  \end{tikzpicture}

  \caption{Diagrama de arquitectura del sistema. Líneas continuas: comunicación serie/MQTT. Líneas discontinuas: LoRa inalámbrico.}
  \label{fig:diagrama-arquitectura}
\end{figure}

\subsection*{Diseño de circuitos con KiCad}
Para homogeneizar el diseño de los circuitos entre todos los miembros del grupo, se utilizó KiCad como herramienta común
 para el esquemático y el diseño de PCB. En KiCad se modeló el divisor de tensión de la LDR, lo que permitió compartir los mismos 
 ficheros de proyecto y reducir errores de cableado entre montajes físicos.

KiCad es una suite de diseño electrónico libre y de código abierto, ampliamente utilizada en entornos académicos y profesionales 
para el diseño de circuitos impresos \cite{kicad}. Además, su documentación oficial facilita la configuración de reglas de 
diseño y la generación de los \emph{layouts} necesarios para el montaje \cite{kicad-docs}.
