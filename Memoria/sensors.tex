\section*{Notas}

\begin{itemize}
  \item Por incompatibilidades de hardware, se usó \texttt{SoftwareSerial.h} para reemplazar \texttt{Serial1}.
  \item Todas las placas conectadas a la antena LoRa están conectadas a una batería para manejar la tensión y no quemar la placa.
  \item Se heredó código de las prácticas 2 y 3.
\end{itemize}

\section*{Esclavo (\texttt{esclavo.ino})}

Se encarga de la gestión directa de sensores.

Dichos sensores son:
\begin{itemize}
  \item dos sensores ultrasónicos de distancia conectados mediante el bus I2C (SRF01 y SRF02)
  \item un sensor de luz de tipo analógico (LDR).
\end{itemize}

Cada sensor dispone de una estructura de configuración propia que almacena su dirección, unidad de medida, retardo mínimo, modo de funcionamiento (periódico o puntual), periodo de muestreo y último valor leído, heredado de la práctica 2.

\begin{lstlisting}[language=C++]
struct SensorConfig {
  uint8_t address;
  uint8_t unit;
  uint16_t delayMs;
  bool periodic;
  uint16_t periodMs;
  unsigned long lastShot;
  uint16_t lastMeasure;
  bool active;
  char name[8];
};
\end{lstlisting}

Durante la fase de inicialización, el dispositivo detecta automáticamente la presencia de los sensores I2C y habilita por defecto las mediciones periódicas (1s) para aquellos sensores activos, realizando además una lectura inicial de cada uno de ellos. El esclavo mantiene un propio temporizador basado usando \textit{millis()} para enviar las lecturas periódicas al maestro de todos los sensores.

En funcionamiento normal, el esclavo ejecuta la ejecución de las mediciones periódicas programadas, enviando al maestro los valores obtenidos de forma estructurada. De este modo, el dispositivo actúa como un módulo autónomo de adquisición de datos.

\begin{lstlisting}[language=C++]
// lectura de los SRF02
uint16_t readSRF02(uint8_t address, uint8_t unit){...}
// lectura del photoresistor
analogRead(A1);
// envio del paquete por Serial1
void sendResponse(uint8_t code, uint8_t* data = nullptr, uint8_t len = 0){...}
\end{lstlisting}

Sin embargo por no se eliminaron funcionalidades extra de la práctica 2 (recepción/ejecución de comandos), por lo que de ser necesario, puede cambiar la configuración de lecturas, por ejemplo aumentar o disminuir el periodo de las lecturas.

\section*{Maestro (\texttt{maestro.ino})}

El maestro supervisa del sistema de sensores, interpreta de las mediciones recibidas y las publica como par etiqueta-valor a través de una red LoRa, de esa forma el receptor puede asociar el valor a un ``Topic'' de un servidor MQTT.

El maestro se comunica con el dispositivo esclavo por el canal serie, recibiendo las mediciones de los sensores. Las medidas crudas recibidas son procesadas aplicando umbrales para convertirlas en estados binarios representativos del entorno, como la detección de oscuridad o la presencia de un objeto cercano.

\begin{lstlisting}[language=C++]
#define LIGHT_THRESHOLD   500   // Si luz < 500 -> 1 (oscuro y se necesita encender luz)
#define DISTANCE_THRESHOLD 100  // Si distancia < 100cm -> 1 (objeto cerca, abrir puerta)
\end{lstlisting}

Para la comunicación inalámbrica se utiliza un módulo LoRa configurado con parámetros específicos de frecuencia, ancho de banda, factor de expansión y potencia de transmisión. Los datos se envían encapsulados en paquetes estructurados que incluyen direccionamiento, numeración de mensajes y un identificador de tópico, permitiendo su correcta interpretación en un nodo gateway.

\begin{lstlisting}[language=C++]
//configuracion LoRa
#define LORA_LOCAL_ADDRESS      0x04
#define LORA_GATEWAY_ADDRESS    0x05
#define LORA_FREQUENCY          868E6
#define LORA_BW                 62.5E3
#define LORA_SF                 10
#define LORA_CR                 5
#define LORA_TP                 2
#define LORA_SYNC_WORD          0x12
#define LORA_PREAMBLE_LENGTH    8

//datos 
struct SensorMessage {
  uint8_t payload;
  bool pending;
  uint8_t lastSentValue;  // Último valor enviado para detectar cambios
};
\end{lstlisting}

El sistema de envío LoRa está diseñado para ser reactivo y eficiente, evitando la transmisión de información redundante y la saturación del canal. Para ello, el maestro mantiene una cola lógica de mensajes pendientes por cada tipo de sensor y solo programa un envío cuando se detecta un cambio de estado o durante el arranque inicial.

\begin{lstlisting}[language=C++]
// Mensaje pendiente para cada sensor (solo 1 por sensor/topic)

struct SensorMessage {
  uint8_t payload;
  bool pending;
  uint8_t lastSentValue;  // Último valor enviado para detectar cambios
};
\end{lstlisting}

Por la evolución de las versiones del proyecto, se trata como cola aunque realmente se mantiene es el ultimo estado (0,1) de un sensor (0,1).

Además, los envíos se alternan entre sensores y se introduce un retardo mínimo entre transmisiones, lo que reduce la carga del canal y mejora la fiabilidad del sistema.

\begin{lstlisting}[language=C++]
// 500ms entre actualizaciones (más rápido)
const unsigned long LORA_SEND_INTERVAL = 500;  

// Flag para alternar entre sensores: false = luz, true = distancia
volatile bool sendDistanceNext = false;
\end{lstlisting}

Puesto que hereda código de la práctica 3, el maestro incluye también una interfaz de comandos por el monitor serie que permite al usuario interactuar con el esclavo de forma manual, solicitando mediciones, modificando configuraciones y consultando el estado de los sensores. Por lo que de ser necesario, se puede manipular la lectura de los sensores.
